h1. More Stuff


h2. Help Tasks

Buildr includes a number of informative tasks.  Currently that number stands
at two, but we'll be adding more tasks in future releases.

To start with, type:

{{{!sh
$ buildr help
}}}

You can list the name and description of all your projects using the
@help:projects@ task.  For example:

{{{!sh
$ buildr help:projects
killer-app                 # Code. Build. ??? Profit!
killer-app:teh-api         # Abstract classes and interfaces
killer-app:teh-impl        # All those implementation details
killer-app:la-web          # What our users see
}}}

You are, of course, describing your projects for the sake of those who will
maintain your code, right?  To describe a project, or a task, call the @desc@
method before the project or task definition.


h2. Environment and Personal Settings

In many cases you will want to customize your build to deal with different
environments and configurations, customize how it runs on your machine, and
even control the build each time you run the @buildr@ command.  The following
sections will show you how to do that.


h4. Environments

One common use case is adapting the build to different environments.  For
example, to compile code with debugging information during development and
testing, but strip it for production.  Another example is using different
databases for development, testing and production, or using services at
different URLs.

So let's start by talking about the build environment.  Buildr has a global
attributes that indicates which environment it's running in, accessible from the
@environment@ method.  You can set the current build environment in one of two
ways.  Using the @-e@ command line option:

{{{!sh
$ buildr -e test
(in /home/john/project, test)
}}}

Or by setting the environment variable @BUILDR_ENV@:

{{{!
$ export BUILDR_ENV=production
$ buildr
(in /home/john/project, production)
}}}

The default environment is "development".

Here's a simple example for handling different environments within the
Buildfile:

{{{!ruby
project 'db-module' do
  db = (environment == 'production' ? 'oracle' : 'hsql')
  resources.from(_(:source, :main, db))
end
}}}


h4.  Profiles

Different environments may require different configurations, and you can handle
a lot of that by using the profile file.  The profile file is a YAML file
called @profile.yaml@ that you place in the same directory as the Buildfile.
We selected YAML because it's easier to read and edit than XML.

For example, to support three different database configurations, we could write:

{{{!yaml
development:
  db: hsql
test:
  db: oracle
production:
  db: oracle
}}}

And change the Buildfile to use the profile:

{{{!ruby
project 'db-module' do
  db = profile['db']
  resources.from(_(:source, :main, db))
end
}}}

The @profile@ method returns a profile that matches the current environment.
For the development environment, it returns a hash with the name/value pair
@'db'=>'hsql'@.

You can "learn more about YAML here":http://www.yaml.org, and use this handy
"YAML quick reference":http://www.yaml.org/refcard.html.


h4. Personal Settings

Some things clearly do not belong in the Buildfile.  For example, the
username/password you use to upload releases.  If you're working in a team or
on an open source project, you'd want to keep these in a separate place.

You may want to use personal settings for picking up a different location for
the local repository, or use a different set of preferred remote repositories,
and so forth.

Before loading the Buildfile, Buildr will attempt to load two @buildr.rb@
files.  First, the @buildr.rb@ file it finds in your home directory, and then
the @buildr.rb@ file it finds in the build directory.  That order is important,
it allows you to place global settings that affect all your builds in your home
directory's @buildr.rb@, but also over-ride those with settings for a given
project.

Here's an example @buildr.rb@:

{{{!ruby
# Only I should know that
repositories.upload_to[:username] = 'assaf'
repositories.upload_to[:password] = 'supersecret'
# Search here first, it's faster
repositories.remote << 'http://inside-the-firewall'
}}} 


h4.  Environment Variables

Buildr uses several environment variables that help you control how it works.
Environment variables are used in addition to profiles and personal settings in
two cases:

* When you need to control the build from the command line, for example,
specifying the build environment using @BUILDR_ENV@, or skipping tests using
@test=no@.

* For commonly used environment variables, such as @JAVA_HOME@, @JAVA_OPTS@ and
@HTTP_PROXY@.

Some environment variables you will only set once or change infrequently.
Other environment variables may change more often, for example, running a build
with different versions of the JDK, or disabling tests.  You can change these
variables when running Buildr by adding @name=value@ as a command line argument.

For example:

{{{!sh
$ buildr test=no
}}}

You can also change environment variables from within the Buildfile.  For
example, if your build needs more JVM heap space than the default, you can add
a line like this to your Buildfile:

{{{!ruby
# This project builds a lot of code.
ENV['JAVA_OPTS'] = '-Xms1g -Xmx1g'
}}}

Make sure to set environment variables at the very top of the Buildfile, above
any @requires@ or other Ruby statements.

Buildr uses the following environment variables.

*BUILDR_ENV* -- Environment name that you can also set using the @-e@ command
line option.

*DEBUG* -- Set to @off@ if you want Buildr to compile without debugging
information (default when running @release@, see
"Compiling":building.html#compiling).

*HTTP_PROXY* -- URL for HTTP proxy server (see "Specifying
Repositories":artifacts.html#specifying_repositories).

*JAVA_HOME* -- Points to your JDK, required for running Buildr.

*JAVA_OPTS/JAVA_OPTIONS* -- Command line options to pass to the JDK (e.g.
@'-Xms1g'@)[1].

*NO_PROXY* -- Comma separated list of hosts and domain that should not be
proxied (see "Specifying
Repositories":artifacts.html#specifying_repositories).

*TEST* -- Set to @off@ to tell Buildr to skip tests, or @all@ to tell Buildr
to run all tests and ignore failures (see "Running
Tests":testing.html#running_tests).

*USER* -- Tasks that need your user name, for example to log to remote serers,
will use this environment variable.

If you need to, you can always use more environment variables.  This example
uses two environment variables for specifying the username and password for
uploading artifacts:

{{{!ruby
repositories.upload_to[:username] = ENV['USERNAME']
repositories.upload_to[:password] = ENV['PASSWORD']
}}}


h2. Eclipse, IDEA

If you're using Eclipse, you can generate @.classpath@ and @.project@ from
your Buildfile and use them to create a project in your workspace:

{{{!sh
$ buildr eclipse
}}}

The @eclipse@ task will generate a @.classpath@ and @.project@ file for each
of projects (and sub-project) that compiles source code.  It will not generate
files for other projects, for examples, projects you use strictly for
packaging a distribution, or creating command line scripts, etc.

If you add a new project, change the dependencies, or make any other change to
your Buildfile, just run the @eclipse@ task again to re-generate the Eclipse
project files.

If you prefer IntelliJ IDEA, you can always:

{{{!sh
$ buildr idea
}}}

It will generate a @.iml@ file for every project (or subproject) and a @.ipr@
that you can directly open for the root project.  To allow IntelliJ Idea to
resolve external dependencies properly, you will need to add a @M2_REPO@
variable pointing to your Maven2 repository directory (@Settings / Path
Variables@).


h2. Cobertura, JDepend

You can use "Cobertura":http://cobertura.sourceforge.net/ to instrument your
code, run the tests and create a test coverage report in either HTML or XML
format.

There are two tasks, both of which generate a test coverage report in the
@reports/cobertura@ directory.  For example:

{{{!sh
$ buildr test cobertura:html
}}}

As you can guess, the other task is @cobertura:xml@.

You can use "JDepend":http://clarkware.com/software/JDepend.html on to
generate design quality metrics.  There are three tasks this time, the eye
candy one:

{{{!sh
$ buildr jdepend:swing
}}}

The other two tasks are @jdepend:text@ and @jdepend:xml@.

We want Buildr to load fast, and not everyone cares for these tasks, so we
don't include them by default.  If you want to use either one, you need to
require it explicitly.  The proper way to do it in Ruby:

{{{!ruby
require 'buildr/cobertura'
require 'buildr/jdepend'
}}}

You may want to add those to the Buildfile.  Alternatively, you can use these
tasks for all your projects without modifying the Buildfile.  One convenient
method is to add these two likes to the @buildr.rb@ file in your home
directory.

Another option is to require it from the command line (@--require@ or @-r@),
for example:

{{{!sh
$ buildr --require buildr/jdepend jdepend:swing
$ buildr -rbuildr/cobertura cobertura:html
}}}


h2. Anything Ruby Can Do

Buildr is Ruby code.  That's an implementation detail for some, but a useful
features for others.  You can use Ruby to keep your build scripts simple and
DRY, tackle ad hoc tasks and write reusable features without the complexity of
"plugins".

We already showed you one example where Ruby could help.  You can use Ruby to
manage dependency by setting constants and reusing them, grouping related
dependencies into arrays and structures.

You can use Ruby to perform ad hoc tasks.  For example, Buildr doesn't have
any pre-canned task for setting file permissions.  But Ruby has a method for
just, so it's just a matter of writing a task:

{{{!ruby
bins = file('target/bin'=>FileList[_('src/main/dist/bin/*')]) do |task|
  mkpath task.name
  cp task.prerequisites, task.name
  chmod 0755, FileList[task.name + '/*.sh'], :verbose=>false
end
}}}

You can use functions to keep your code simple.  For example, in the ODE
project we create two binary distributions, both of which contain a common set
of files, and one additional file unique to each distribution.  We use a
method to define the common distribution:

{{{!ruby
def distro(project, id)
  project.package(:zip, :id=>id).path("#{id}-#{version}").tap do |zip|
    zip.include meta_inf + ['RELEASE_NOTES', 'README'].map { |f| path_to(f) }
    zip.path('examples').include project.path_to(:source, :examples), :as=>'.'
    zip.merge project('ode:tools-bin').package(:zip)
    zip.path('lib').include artifacts(COMMONS.logging, COMMONS.codec,
      COMMONS.httpclient, COMMONS.pool, COMMONS.collections, JAXEN, SAXON,
      LOG4J, WSDL4J, XALAN, XERCES)
    project('ode').projects('utils', 'tools', 'bpel-compiler', 'bpel-api',
      'bpel-obj', 'bpel-schemas').map(&:packages).flatten.each do |pkg|
        zip.include(pkg.to_s, :as=>"#{pkg.id}.#{pkg.type}", :path=>'lib')
      end
    yield zip
  end
end
}}}

And then use it in the project definition:

{{{!ruby
define 'distro-axis2' do
  parent.distro(self, "#{parent.id}-war") { |zip|
    zip.include project('ode:axis2-war').package(:war), :as=>'ode.war' }
end
}}}

Ruby's functional style and blocks make some task extremely easy.  For
example, let's say we wanted to count how many source files we have, and total
number of lines:

{{{!ruby
sources = projects.map { |prj| prj.compile.sources.
  map { |src| FileList["#{src}/**/*.java"] } }.flatten
puts "There are #{source.size} source files"
lines = sources.inject(0) { |lines, src| lines += File.readlines(src).size }
puts "That contain #{lines} lines"
}}}


fn1. Buildr does not check any of the arguments in @JAVA_OPTS@.  A common mistake is to pass an option like @mx512mb@, where it should be @Xmx512mb@.  Make sure to double check @JAVA_OPTS@.
